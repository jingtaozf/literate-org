# -*- Mode: POLY-ORG ; common-lisp-style: elisp; indent-tabs-mode: nil;  -*- ---
#+Title: Literate Programming  in Org files.
#+OPTIONS: tex:verbatim toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STARTUP: noindent
#+STARTUP: inlineimages
#+PROPERTY: literate-lang python
#+PROPERTY: literate-load yes
#+PROPERTY: literate-insert-header no
#+PROPERTY: header-args :results silent :session :tangle no
#+PROPERTY: LITERATE_ORG_EXPORT_DIRECTORY: ./literate_python
* Table of Contents                                            :noexport:TOC:
- [[#introduction][Introduction]]
- [[#a-minor-mode-for-literate-org][A minor mode for literate org]]
  - [[#keymap][keymap]]
  - [[#definition][definition]]
  - [[#enable-literate-org-mode-in-org-file][enable literate org mode in org file]]
  - [[#format-org-code-block-when-save][format org code block when save]]
  - [[#format-all-org-code-blocks-in-current-buffer][format all org code blocks in current buffer]]
  - [[#tangle-current-file-when-save][tangle current file when save]]
  - [[#xref-backend][xref backend]]
    - [[#visit-a-point-in-the-tangled-file-of-a-code-block][visit a point in the tangled file of a code block]]
    - [[#visit-a-point-in-a-code-block-in-the-tangled-file][visit a point in a code block in the tangled file]]
    - [[#show-xrefs-in-org-file-if-possible][show xrefs in org file if possible]]
    - [[#find-definitions][find definitions]]
    - [[#describe-thing-at-point][describe thing at point]]
- [[#python-library-for-a-literate-server][Python library for a literate server]]
  - [[#idea][Idea]]
  - [[#prototype][Prototype]]
  - [[#module-layout-in-an-org-file][Module Layout in an Org file]]
  - [[#implementation-in-python-side][Implementation in python side]]
    - [[#__init__][__init__]]
    - [[#__main__][__main__]]
    - [[#literate-module-loader][literate module loader]]
    - [[#build-hierarchical-code-structure][build hierarchical code structure]]
    - [[#web-server][web server]]
  - [[#tests][Tests]]
    - [[#test-update-locals-in-marimo-notebook-automatically][test update locals in marimo notebook automatically]]
- [[#emacs-library-for-python-literate-server][Emacs library for python literate server]]
  - [[#import-required-elisp-libraries][Import required elisp libraries]]
  - [[#utilities][Utilities]]
    - [[#connect-to-a-literate-server][connect to a literate server]]
    - [[#send-request-to-remote-literate-server][send request to remote literate server]]
  - [[#source-code-execution][Source Code Execution]]
    - [[#customized-variables-for-server-host-and-port][customized variables for server host and port]]
    - [[#execute-source-codes-in-specified-module-for-org-babel-python-evaluate][execute source codes in specified module for org-babel-python-evaluate]]
    - [[#execute-source-code-in-remote-server][execute source code in remote server]]
    - [[#execute-source-code-in-current-code-block][execute source code in current code block]]
    - [[#get-top-level-python-code][get top level python code]]
    - [[#get-the-module-name-for-a-file-name][get the module name for a file name]]
    - [[#load-python-code-to-current-module][load python code to current module]]
- [[#python-inspector-for-emacs][Python inspector for Emacs]]
    - [[#import-required-packages][Import required packages]]
    - [[#utility-functions][Utility functions]]
    - [[#dispatches-the-appropriate-inspection-according-to-obj-type][Dispatches the appropriate inspection according to obj type]]
    - [[#inspect-as-json][inspect as json]]
- [[#sync-between-org-files-and-source-files][Sync between org files and source files]]
  - [[#introduction-1][Introduction]]
  - [[#import][Import]]
    - [[#how][How]]
    - [[#implementation][Implementation]]
  - [[#export][Export]]
- [[#run-python-code-in-specified-module][Run python code in specified module]]
  - [[#setup-current-module-in-python-repl][setup current module in python REPL]]
    - [[#a-special-variable-for-current-module-name-in-python-repl][a special variable for current module name in python REPL]]
    - [[#display-namespace-in-the-mode-line-in-buffer-for-python-repl][display namespace in the mode line in buffer for python REPL]]
    - [[#a-comint-input-sender-to-exec-code-in-a-namespace][a comint input sender to exec code in a namespace.]]
  - [[#setup-python-shell-eval-setup-code][setup python shell eval setup code]]
- [[#utilities-1][Utilities]]
  - [[#clear-subtree][clear subtree]]
  - [[#import-from-jupyter-notebook][import from jupyter notebook]]
    - [[#convert-markdown-to-org-syntax][convert markdown to org syntax]]
    - [[#parse-a-notebook-file][parse a notebook file]]
- [[#tips][Tips]]
  - [[#how-to-start-django-server-in-repl][how to start django server in REPL]]
- [[#todo01][TODO]]
- [[#references][References]]

* Introduction
I have used an org file to write my document and code for a long time, in various languages.

It is very convenient to write code in an org file.
For example, instead of managing multiple files in nested directories,
I can write code in an org file with a clear structure in a more lightweight way.
Also, it can contain both documentation and code in one file for all my projects.

Now I want to use org file to write Python code,
and I want to import Python modules from an org file for my projects.

So comes this library to help me import Python modules from org files in Emacs.
* A minor mode for literate org
:PROPERTIES:
:literate-lang: elisp
:header-args: :results silent :session :tangle no
:END:
** keymap
#+BEGIN_SRC elisp
(defvar literate-org-mode-map (make-sparse-keymap)
  "Keymap for `literate-org-mode`.")
#+END_SRC

** definition
#+BEGIN_SRC elisp
(define-minor-mode literate-org-mode
    "Mode for org buffers with code blocks."
  :lighter nil
  (cond
    (literate-org-mode
     (when (aand (buffer-file-name (current-buffer))
                 (equal "org" (f-ext it)))
       (when (buffer-base-buffer)
         (with-current-buffer (buffer-base-buffer)
           ;; The command `save-buffer` utilizes the base buffer for an indirect buffer.
           (add-hook 'before-save-hook 'literate-org-format-code-block -50 t)
           (add-hook 'after-save-hook 'literate-org-tangle-current-file -50 t)
           (add-hook 'xref-backend-functions #'literate-org-xref-backend -50 t)))))
    (t
     (when (equal "org" (f-ext (buffer-file-name (current-buffer))))
       (when (buffer-base-buffer)
         (with-current-buffer (buffer-base-buffer)
           (remove-hook 'before-save-hook 'literate-org-format-code-block t)
           (remove-hook 'after-save-hook 'literate-org-tangle-current-file t)))
       (remove-hook 'xref-backend-functions #'literate-org-xref-backend t)))))
#+END_SRC
** enable literate org mode in org file
#+BEGIN_SRC elisp
(defun literate-org-mode-in-org-file ()
  (when (aand (buffer-file-name (current-buffer))
                 (equal "org" (f-ext it)))
    (literate-org-mode 1)))
#+END_SRC
** format org code block when save
#+BEGIN_SRC elisp
(defun literate-org-format-code-block ()
  (interactive)
  (when (org-in-block-p '("src"))
    (let* ((language (getf (second (org-element-at-point)) :language))
           (header-args (cl-third (org-babel-get-src-block-info 'light)))
           (file-name (cdr (assoc :tangle header-args))))
      (cond ((find language '("python" "ipython") :test #'equalp)
             (python-black-org-mode-block t))
            ((find language '("tsx" "ts" "js" "vue" "vue-html" "css") :test #'equalp)
             (let ((prettier-major-mode-parsers
                    (append '((vue-html-mode vue)
                              (tsx-ts-mode typescript))
                            prettier-major-mode-parsers)))
               (prettier-prettify-org-src-code-at-point)))
            ((null language) (error "Unsupported language %s" language))))))
#+END_SRC
** format all org code blocks in current buffer
#+BEGIN_SRC elisp
(defun literate-org-format-code-blocks-in-current-buffer ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "#\\+BEGIN_SRC" nil t)
      (forward-line 1)
      (unless (string-prefix-p "#+END_SRC"
                               (buffer-substring-no-properties
                                (line-beginning-position) (line-end-position)))
        (literate-org-format-code-block)))))
#+END_SRC
** tangle current file when save
#+BEGIN_SRC elisp
(defun literate-org-tangle-current-file ()
  (interactive)
  (when-let* ((header-args (cl-third (org-babel-get-src-block-info 'light)))
              (file-name (cdr (assoc :tangle header-args))))
    (if (and file-name (not (equal file-name "no")))
        (progn
          (org-babel-tangle '(16) file-name (f-ext file-name))
          (run-hook-with-args 'literate-org-after-tangle-current-file file-name))
      ;; Try to find the parent code block usng the current noweb-ref and tangle it.
      (when-let* ((noweb-ref (cdr (assoc :noweb-ref header-args))))
        (message "No tangle file specified.")
        (let ((noweb-ref-body (format "<<%s>>" noweb-ref)))
          (save-excursion
            (save-restriction
              (goto-char (point-min))
              (while (search-forward noweb-ref-body nil t)
                (when-let* ((header-args (cl-third (org-babel-get-src-block-info 'light)))
                            (file-name (cdr (assoc :tangle header-args)))
                            (actual-file-p (and file-name (not (equal file-name "no")))))
                  (org-babel-tangle '(16) file-name (f-ext file-name))
                  (run-hook-with-args 'literate-org-after-tangle-current-file file-name))))))))))
#+END_SRC
** xref backend
*** visit a point in the tangled file of a code block
#+BEGIN_SRC elisp
(defun literate-org-visit-point-at-tangled-position ()
  (when-let* ((header-args (cl-third (org-babel-get-src-block-info 'light)))
              (file-name (cdr (assoc :tangle header-args))))
    (when (file-exists-p file-name)
      (let* ((column-index (- (point) (line-beginning-position)))
             (last-code-block-line-no (save-excursion
                                        (search-backward-regexp "^#\\+BEGIN_SRC" nil t)
                                        (line-number-at-pos)))
             (line-index (- (line-number-at-pos)
                            last-code-block-line-no
                            1))
             ;; for each code block before the current code block for the same tangled file, count lines of each code block
             (lines-of-before-code-blocks nil))
        (save-excursion
          (search-backward (format ":header-args: :tangle %s" file-name) nil)
          (search-forward "#+BEGIN_SRC" nil)
          (let ((begin-line-no (line-number-at-pos)))
            (while (< begin-line-no last-code-block-line-no)
              (setf begin-line-no (line-number-at-pos))
              (search-forward "#+END_SRC" nil)
              (push (- (line-number-at-pos) begin-line-no 1)
                    lines-of-before-code-blocks)
              (search-forward "#+BEGIN_SRC" nil)
              (setf begin-line-no (line-number-at-pos)))))
        (setf lines-of-before-code-blocks (reverse lines-of-before-code-blocks))
        (with-current-buffer (find-file-noselect file-name)
          (goto-char (point-min))
          (while lines-of-before-code-blocks
            (forward-line (pop lines-of-before-code-blocks))
            (while (and (not (eobp))
                        (save-excursion
                          (beginning-of-line)
                          (looking-at-p "^\\s-*$")))
              (forward-line 1)))
          (forward-line line-index)
          (goto-char (line-beginning-position))
          (forward-char column-index)
          (values file-name (point)))))))
#+END_SRC


*** visit a point in a code block in the tangled file
#+BEGIN_SRC elisp
(cl-defun literate-org-point-at-code-block-of-tangled-location (org-buffer file-name point)
  (when (file-exists-p file-name)
    (with-current-buffer (find-file-noselect file-name)
      (save-excursion
        (goto-char point)
        (let* ((column-index (- (point) (line-beginning-position)))
               (line-index (line-number-at-pos))
               (org-point nil)
               (org-current-block-start-line nil)
               (org-current-block-lines 0))
          (goto-char (point-min))
          (with-current-buffer org-buffer
            (save-excursion
              (goto-char (point-min))
              (when (search-forward (format ":header-args: :tangle %s" file-name) nil t)
                (setf org-point (point)))))
          (when (null org-point)
            (cl-return-from literate-org-point-at-code-block-of-tangled-location nil))
          ;; while current block is not for current tangled line
          (while (<= (+ (line-number-at-pos) org-current-block-lines) line-index)
            ;; forward current block in tangled file.
            (forward-line org-current-block-lines)
            (while (and (not (eobp))
                        (save-excursion
                          (beginning-of-line)
                          (looking-at-p "^\\s-*$")))
              (forward-line 1))
            ;; search next code block in org buffer
            (with-current-buffer org-buffer
              (save-excursion
                (goto-char org-point)
                (search-forward "#+BEGIN_SRC" nil)
                (forward-line)
                (setf org-point (point))
                (setf org-current-block-start-line (line-number-at-pos))
                (search-forward "#+END_SRC" nil)
                (setf org-current-block-lines (- (line-number-at-pos) org-current-block-start-line)))))
          (let ((lines (- line-index (line-number-at-pos))))
            (with-current-buffer org-buffer
              (save-excursion
                (goto-char org-point)
                (forward-line lines)
                (goto-char (line-beginning-position))
                (forward-char column-index)
                (point-marker)))))))))
#+END_SRC


*** show xrefs in org file if possible
#+BEGIN_SRC elisp
(defun literate-org-xref-show-definitions-buffer (fetcher alist)
  (let ((xrefs (funcall fetcher))
        (org-buffer (current-buffer)))
    (loop for xref in xrefs
          for location = (xref-match-item-location xref)
          for group = (xref-location-group location)
          for org-point-marker = (literate-org-point-at-code-block-of-tangled-location
                                   org-buffer group (marker-position (xref-location-marker location)))
          if org-point-marker
            do (setf (xref-match-item-location xref)
                       (xref-make-buffer-location org-buffer (marker-position org-point-marker))))
    (let (buf)
      (cond
        ((not (cdr xrefs))
         (xref-pop-to-location (car xrefs)
                               (assoc-default 'display-action alist)))
        (t
         (setq buf
                 (xref--show-xref-buffer fetcher
                                         (cons (cons 'fetched-xrefs xrefs)
                                               alist)))
         (xref--auto-jump-first buf (assoc-default 'auto-jump alist))
         buf)))))
#+END_SRC

*** find definitions
We try to open the tangled file, and move cursor to the same point as it is in the code block,
then use lsp mode to find the definition, if the target position can be found in the current org file, we'll
move point to the target position.
#+BEGIN_SRC elisp
(defun literate-org-find-dwim ()
  (interactive)
  (unless (string= "org" (f-ext (buffer-file-name (current-buffer))))
    (lsp-find-definition)
    (return))

  (multiple-value-bind (tangled-file-name tangled-point)
      (literate-org-visit-point-at-tangled-position)
    (let ((loc
           (with-current-buffer (find-file-noselect tangled-file-name)
             (lsp 1)
             (goto-char tangled-point)
             (lsp-request "textDocument/definition" (lsp--text-document-position-params)))))
      (if (seq-empty-p loc)
        (lsp--error "Not found for: %s" (or (thing-at-point 'symbol t) ""))
        (let ((xref-show-definitions-function 'literate-org-xref-show-definitions-buffer))
          (lsp-show-xrefs (lsp--locations-to-xref-items loc) nil nil))))))
#+END_SRC
*** describe thing at point
#+BEGIN_SRC elisp
(defun literate-org-describe-thing-at-point ()
  (interactive)
  (unless (string= "org" (f-ext (buffer-file-name (current-buffer))))
    (lsp-describe-thing-at-point)
    (return))

  (multiple-value-bind (tangled-file-name tangled-point)
      (literate-org-visit-point-at-tangled-position)
    (with-current-buffer (find-file-noselect tangled-file-name)
      (lsp 1)
      (goto-char tangled-point)
      (lsp-describe-thing-at-point))))
#+END_SRC

* Python library for a literate server
:PROPERTIES:
:header-args: :results silent :session :tangle no
:END:
** Idea
Python has a flexible module import system that allows you to customize how modules are imported.
This enables us to import modules from a different file format (e.g. an org file).

This approach allows you to maintain and organize your Python code blocks in different modules within one .org file
while dynamically loading it into Python’s namespace.
It leverages Emacs’ powerful editing capabilities along with
Python’s flexible import system to create a seamless workflow for developing and running Python code.

We also provide a way to execute Python code blocks in org files within specified Python modules,
to allow for a more interactive development experience.
** Prototype
:PROPERTIES:
:header-args: :results silent :session :tangle no
:END:
Let's do some tests in Python.

1. import the necessary modules
#+BEGIN_SRC python
import sys
import importlib
#+END_SRC

2. create a new module dynamically
#+BEGIN_SRC python
spec_module_a = importlib.util.spec_from_loader("module_a", loader=None)
module_a = importlib.util.module_from_spec(spec_module_a)
sys.modules["module_a"] = module_a
#+END_SRC

3. add a function to the module
#+BEGIN_SRC python
exec('def say_hello(): print("Hello from module_a.")', module_a.__dict__)
exec('def a(): return 3', module_a.__dict__)
exec('def b(): return 4 + a()', module_a.__dict__)
#+END_SRC
4. run this function
#+BEGIN_SRC python
from module_a import say_hello
from module_a import b
say_hello()
b()
#+END_SRC

It works well.
** Module Layout in an Org file
We can organize Python code blocks in org files in the following way:
- The org sections are used to separate different modules.
  - The org sections has the same hierarchy as the Python modules.
  - The Python module name is defined in the property with name =LITERATE_ORG_MODULE= in the section.
- The Python code blocks in each section are used to define the functions and classes in the module.
- A code block is loaded conditionally by the org property =LITERATE_ORG_LOAD= or header argument =load=.
    - The property is not set.
    - The property is set to =yes=.
    - The property is found in the environment =LITERATE_ORG_LOAD=.

For example      
#+BEGIN_EXAMPLE
 * Module A
   :PROPERTIES:
   :LITERATE_ORG_MODULE: module_a
   :END:
  ** Module A.a
   :PROPERTIES:
   :LITERATE_ORG_MODULE: module_a.a
   :END:
  *** a function for module A.a
   ,#+BEGIN_SRC python
   def say_hello():
        print("Hello from module_a.a.")
   ,#+END_SRC
  *** a test code for above function
   ,#+BEGIN_SRC python :load test
   say_hello()
   ,#+END_SRC
#+END_EXAMPLE
** Implementation in python side
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python
:LITERATE_ORG_ROOT_MODULE_PATH: ./
:END:
*** __init__
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.__init__
:header-args: :tangle ./literate_python/__init__.py
:END:
**** Assignment __version__
#+BEGIN_SRC python
__version__ = "0.0.5"

#+END_SRC
*** __main__
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.__main__
:header-args: :tangle ./literate_python/__main__.py
:END:
**** Import statements
#+BEGIN_SRC python
from .pipe import run_server

#+END_SRC
**** Call run_server
#+BEGIN_SRC python
run_server()

#+END_SRC
*** literate module loader
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.loader
:header-args: :tangle ./literate_python/loader.py
:END:
**** Import statements
#+BEGIN_SRC python
import sys
import types
import importlib
import importlib.abc
import importlib.machinery
import logging
import orgparse

#+END_SRC
**** logger
#+BEGIN_SRC python
logger = logging.getLogger(__name__)

#+END_SRC
**** in-memory module storage
***** the global parameter
#+BEGIN_SRC python
if "inMemoryModules" not in globals():
    inMemoryModules = {}

#+END_SRC
***** a method to register a list of modules
#+BEGIN_SRC python
def register_literate_modules(module_spec_list: list) -> None:
    for module_spec in module_spec_list:
        inMemoryModules[module_spec["name"]] = module_spec

#+END_SRC
**** find a module
#+BEGIN_SRC python
def _get_module_spec(fullname: str) -> bool:
    return inMemoryModules.get(fullname) or inMemoryModules.get(fullname + ".__init__")

#+END_SRC

**** a literate module importer
#+BEGIN_SRC python
class LiterateImporter(object):
    def find_module(self, fullname: str, path=None):
        if _get_module_spec(fullname):
            logger.debug(f"Found literate module {fullname}")
            return self
        else:
            return None

    def load_module(self, fullname: str):
        """Create a new module object."""
        mod_spec = _get_module_spec(fullname)
        mod = types.ModuleType(fullname)
        mod.__loader__ = self
        mod.__file__ = mod_spec.get("filepath", "")
        # Set module path - get filepath and keep only the path until filename
        mod.__path__ = ["/".join(mod.__file__.split("/")[:-1]) + "/"]
        mod.__package__ = fullname
        sys.modules[fullname] = mod
        # Execute the module/package code into the Module object
        logger.debug(f"Load literate module {fullname}")
        exec(mod_spec["content"], mod.__dict__)
        return mod

#+END_SRC
**** Register the Loader with the Import System
#+BEGIN_SRC python
class LiterateModuleFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        if _get_module_spec(fullname):
            logger.debug(f"Found literate module {fullname}")
            return importlib.machinery.ModuleSpec(fullname, LiterateImporter())
        return None

#+END_SRC
**** a routine to register the finder
#+BEGIN_SRC python
def register_literate_module_finder():
    sys.meta_path = [
        f for f in sys.meta_path if not isinstance(f, LiterateModuleFinder)
    ]
    print("Register literate importer.\n")
    sys.meta_path.append(LiterateModuleFinder())

#+END_SRC
**** operations with org files
***** load python modules from an org file
#+BEGIN_SRC python
def load_literate_modules_from_org_file(org_file: str) -> None:
    orgparse.load(org_file)

#+END_SRC
***** load literate modules form org nodes
#+BEGIN_SRC python
def load_literate_modules_from_org_node(node: orgparse.OrgNode) -> None:
    # root_module = LITERATE_ORG_ROOT_MODULE
    pass

#+END_SRC

***** build an org model compatible string from a local python package
#+BEGIN_SRC python
def build_org_model_from_local_python_package(package_path: str) -> str:
    pass

#+END_SRC
*** build hierarchical code structure
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.sections
:header-args: :tangle ./literate_python/sections.py
:END:
**** Introduction
The hierarchical code structure is a tree structure that represents the code blocks in an org file.
We group each code block by a hybrid Approach:
- Initial Clustering: Use text similarity analysis to generate initial clusters.
- LLM Refinement: Then, pass the clustered groups to an LLM to refine the groups,
  suggest task names, or provide explanations for why items are grouped together.
**** import statements
#+BEGIN_SRC python
from sentence_transformers import SentenceTransformer
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

#+END_SRC
**** optimal_clusters
#+BEGIN_SRC python
def optimal_clusters(definitions, embeddings, min_k=2, max_k=10, threshold=0.05):
    """
    Computes the optimal clusters for the given definitions and embeddings.

    It evaluates KMeans clustering for k in range(min_k, max_k+1) by computing the
    silhouette score for each k. If a candidate with more clusters has a silhouette score
    only marginally lower than the best score (within the threshold), it favors the higher k.

    Args:
        definitions: List of text definitions (e.g. function, class, or constant definitions).
        embeddings: Numpy array or list of embeddings corresponding to each definition.
        min_k: Minimum number of clusters to try.
        max_k: Maximum number of clusters to try.
        threshold: If the difference between the best score and a candidate score is less than
                   this threshold, choose the candidate with more clusters.

    Returns:
        clusters: A dictionary mapping each cluster label to a list of definitions.
        optimal_k: The optimal number of clusters chosen.
        scores: A dictionary mapping k to its silhouette score.
    """
    scores = {}
    # Limit max_k to the number of samples
    max_k = min(max_k, len(embeddings))

    # If too few samples, return one cluster containing all definitions.
    if len(embeddings) < 2:
        return {0: definitions}, 1, scores

    best_k = None
    best_score = -1

    # Evaluate silhouette scores for each candidate k.
    for k in range(min_k, max_k + 1):
        kmeans = KMeans(n_clusters=k, random_state=42)
        labels = kmeans.fit_predict(embeddings)
        score = silhouette_score(embeddings, labels)
        scores[k] = score
        print(f"k={k}, silhouette score={score:.4f}")

        # For the first candidate, simply assign best_k.
        if best_k is None:
            best_k = k
            best_score = score
        else:
            # If a candidate has a slightly lower score (within threshold) but with more clusters,
            # favor it for increased granularity.
            if score > best_score:
                best_k = k
                best_score = score
            elif (best_score - score) < threshold and k > best_k:
                best_k = k
                best_score = score

    optimal_k = best_k
    print(f"\nOptimal number of clusters chosen: {optimal_k}")

    # Run final clustering with the optimal number of clusters.
    final_kmeans = KMeans(n_clusters=optimal_k, random_state=42)
    final_labels = final_kmeans.fit_predict(embeddings)

    # Group definitions by cluster.
    clusters = {}
    for label, definition in zip(final_labels, definitions):
        clusters.setdefault(label, []).append(definition)

    return clusters, optimal_k, scores

#+END_SRC
**** example
#+BEGIN_SRC python
# Example usage:
def test_optimal_clusters():
    # Sample list of definitions (could be function/class definitions, etc.)
    definitions = [
        "def load_data(filepath):\n    # loads the data from a file",
        "def preprocess_data(data):\n    # cleans and normalizes the data",
        "class DataLoader:\n    # class for loading data from various sources",
        "def train_model(data):\n    # trains a machine learning model",
        "class ModelTrainer:\n    # class that encapsulates the training logic",
        "def predict(input):\n    # makes predictions using the trained model",
        "def render_vue_component(props):\n    // renders a Vue component based on the props",
        "class VueComponent:\n    // defines a Vue component with state and methods",
        "def mount_vue_app(selector, component):\n    // mounts a Vue app to the DOM element",
        # Add more definitions as needed...
    ]

    # Load a pre-trained model to compute sentence embeddings.
    model = SentenceTransformer("all-MiniLM-L6-v2")
    embeddings = model.encode(definitions)

    # Compute optimal clusters.
    clusters, optimal_k, scores = optimal_clusters(
        definitions, embeddings, min_k=2, max_k=5, threshold=0.05
    )

    # Print out the resulting clusters.
    for cluster_id, items in clusters.items():
        print(f"\nCluster {cluster_id}:")
        for item in items:
            print(f"  - {item}")

#+END_SRC


*** web server
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.server
:header-args: :tangle ./literate_python/server.py
:END:
**** Import statements
#+BEGIN_SRC python
import ast
import importlib
import os
import sys
from flask import Flask, request, jsonify

import traceback

from contextlib import redirect_stdout
from contextlib import redirect_stderr
from io import StringIO
from io import StringIO

import logging

from textwrap import shorten
from literate_python.loader import (
    register_literate_modules,
    register_literate_module_finder,
)

from literate_python.inspector import _inspect

#+END_SRC
**** Assignment logger
#+BEGIN_SRC python
logger = logging.getLogger(__name__)

#+END_SRC
**** Assignment app
#+BEGIN_SRC python
app = Flask(__name__)

#+END_SRC
**** collect names in a code
#+BEGIN_SRC python
def get_top_level_names(code):
    tree = ast.parse(code)
    variables = []
    functions = []
    classes = []

    for node in tree.body:
        if isinstance(node, ast.Assign):
            # Handle assignments like x = 1 or x, y = 2, 3.
            for target in node.targets:
                if isinstance(target, ast.Name):
                    variables.append(target.id)
                elif isinstance(target, ast.Tuple):
                    for elt in target.elts:
                        if isinstance(elt, ast.Name):
                            variables.append(elt.id)
        elif isinstance(node, ast.AnnAssign):
            # Handle annotated assignments like: x: int = 1.
            if isinstance(node.target, ast.Name):
                variables.append(node.target.id)
        elif isinstance(node, ast.FunctionDef):
            functions.append(node.name)
        elif isinstance(node, ast.ClassDef):
            classes.append(node.name)

    return variables, functions, classes

#+END_SRC

**** locals in current port
#+BEGIN_SRC python
#: app locals in current port
server_locals = {}

#+END_SRC

**** ensure a module is loaded
#+BEGIN_SRC python
def ensure_module(module_name, module_create_method):
    """Ensure a module is loaded and return it."""
    if module_name in sys.modules:
        return sys.modules[module_name]

    match module_create_method:
        case "create":
            spec_module = importlib.util.spec_from_loader(module_name, loader=None)
            module = importlib.util.module_from_spec(spec_module)
            sys.modules[module_name] = module
            return module
        case "import":
            importlib.import_module(module_name)
            return sys.modules[module_name]
        case "import_or_create":
            if importlib.util.find_spec(module_name):
                importlib.import_module(module_name)
                return sys.modules[module_name]
            else:
                spec_module = importlib.util.spec_from_loader(module_name, loader=None)
                module = importlib.util.module_from_spec(spec_module)
                sys.modules[module_name] = module
                return module
        case _:
            msg = f"Module {module_create_method} doesn't exist"
            raise ValueError(msg)

#+END_SRC

**** Function process_a_message
#+BEGIN_SRC python
def process_a_message(message):
    stdout_stream = StringIO()
    stderr_stream = StringIO()
    error = None
    result = None
    locals = []
    with redirect_stdout(stdout_stream):
        with redirect_stderr(stderr_stream):
            try:
                type = message["type"]
                code = message["code"]
                dict = globals()
                module_name = message["module"] if "module" in message else None
                if module_name:
                    module_create_method = message.get("module-create-method", "import")
                    module = ensure_module(module_name, module_create_method)
                    dict = module.__dict__

                if type == "eval":
                    exec(compile(code, module_name or "code", "exec"), dict)
                    message.get("result-name", "_")
                    result = dict.get("_", None)
                elif type == "exec":
                    result = exec(compile(code, module_name or "code", "exec"), dict)
                    vars_, funcs, classes = get_top_level_names(code)
                    for local in vars_ + funcs + classes:
                        if local in server_locals:
                            _local = server_locals[local]
                            if hasattr(_local, "__module__"):
                                _module_name = _local.__module__
                                if _module_name == module_name:
                                    # update the local with the new value
                                    server_locals[local] = getattr(module, local)
                                    locals.append(local)

                elif type == "quit":
                    result = None
                else:
                    error = "Unknown type: {}".format(type)
                    raise ValueError(error)
            except Exception as e:
                # printing stack trace
                traceback.print_exc()
                error = str(e)
    if error is None:
        return_value = {
            "result": _inspect(result),
            "type": "result",
            "locals": locals,
            "stdout": stdout_stream.getvalue(),
            "stderr": stderr_stream.getvalue(),
        }
    else:
        return_value = {
            "error": error,
            "type": "error",
            "stdout": stdout_stream.getvalue(),
            "stderr": stderr_stream.getvalue(),
        }

    if type == "quit":
        sys.exit(0)
    else:
        return return_value

#+END_SRC
**** register in memory python modules 
**** register
#+BEGIN_SRC python
def register(request):
    # Get JSON data
    data = request.get_json()

    # Process the data (example)
    logger.debug(
        "/register Received:%s", shorten(str(data), width=100, placeholder="...")
    )
    try:
        register_literate_modules(data)
        return_value = {"type": "done"}
    except Exception as e:
        # printing stack trace
        return_value = {"type": "error", "stderr": str(e)}
        traceback.print_exc()

    # Return a response
    logger.debug("/register Returning:%s", return_value)
    return jsonify(return_value)

#+END_SRC

**** @app.route('/lpy/register, methods=['POST']): register literate modules
#+BEGIN_SRC python
@app.route("/lpy/register", methods=["POST"])
def register_router():
    return register(request)

#+END_SRC
**** execute
#+BEGIN_SRC python
def _execute(request):
    # Get JSON data
    data = request.get_json()

    # Process the data (example)
    logger.debug(
        "/execute Received:%s", shorten(str(data), width=100, placeholder="...")
    )
    return_value = process_a_message(data)

    # Return a response
    logger.debug("/execute Returning:%s", return_value)
    return jsonify(return_value)

#+END_SRC

**** @app.route('/execute', methods=['POST']): Function execute
#+BEGIN_SRC python
@app.route("/lpy/execute", methods=["POST"])
def execute():
    return _execute(request)

#+END_SRC

**** status
#+BEGIN_SRC python
def _status(request):
    return jsonify({"status": "ok"})

#+END_SRC

**** status router
#+BEGIN_SRC python
@app.route("/lpy/status", methods=["GET"])
def status():
    return _status(request)

#+END_SRC

**** Function run_web_server
#+BEGIN_SRC python
def run_server():
    host = "127.0.0.1"
    port = 7330
    if "LITERATE_PYTHON_HOST" in os.environ:
        host = os.environ["LITERATE_PYTHON_HOST"]
    if "LITERATE_PYTHON_PORT" in os.environ:
        port = int(os.environ["LITERATE_PYTHON_PORT"])
    register_literate_module_finder()
    app.run(debug=True, port=port, host=host, use_reloader=False)

#+END_SRC

** Tests
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.tests
:END:
*** test update locals in marimo notebook automatically 
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.tests.test_server
:header-args: :tangle ./literate_python/tests/test_server.py
:END:
**** test1
#+BEGIN_SRC python
def test1():
    print("Hello!")

#+END_SRC

* Emacs library for python literate server
:PROPERTIES:
:literate-lang: elisp
:END:
** Import required elisp libraries
#+BEGIN_SRC elisp
(require 'f)
(require 'files)
(require 'ob-python)
(require 'lsp);; for `lsp-workspace-root'
(require 'python-black)
(require 'prettier)
#+END_SRC

** Utilities
*** connect to a literate server
#+BEGIN_SRC elisp
(defun literate-org-connect ()
  (interactive)
  (when-let* ((url (read-from-minibuffer "URL: " literate-org-rest-server)))
    (setf literate-org-rest-server url)
    (literate-org-request "status" :type "GET")
    (message "Connected to %s" literate-org-rest-server)))
#+END_SRC

*** send request to remote literate server
#+BEGIN_SRC elisp
(defvar literate-org-last-response nil)

(cl-defun literate-org-request (path &key params data (type "GET"))
  (setf literate-org-last-response nil)
  (awhen (get-buffer "*literate-org-error*")
    ;; Close the buffer as it will be out of date.
    (kill-buffer it))
  (let* ((request-backend 'url-retrieve)
         (server literate-org-rest-server)
         resp)
    (request (concat server "lpy/" path)
        :params params
        :parser 'json-read
        :type type
        :headers '(("Content-Type" . "application/json"))
        :sync t
        :data (encode-coding-string (json-encode data) 'utf-8 t) ; Encode and ensure unibyte
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-org-last-response response)
                     (case (request-response-status-code response)
                       (200 (setf resp (request-response-data response)))

                       (500 (user-error "Literate Python server failed:%s" response))
                       (t (user-error "Failed to request to remote Python server:%s" response))))))
    (let ((type (cdr (assoc 'type resp))))
      (cond ((equal type "error")
             (let ((stdout (cdr (assoc 'stdout resp)))
                   (stderr (cdr (assoc 'stderr resp))))
               (with-current-buffer (get-buffer-create "*literate-org-error*")
                 (erase-buffer)
                 (insert "=== Data ===\n" (encode-coding-string (json-encode data) 'utf-8 t) "\n\n")
                 (insert "==== Error ===\n" (or (cdr (assoc 'error resp)) ""))
                 (when stdout 
                   (insert "\n\n=== stdout ===\n" stdout))
                 (when stderr
                   (insert "\n\n=== stderr ===\n" (cdr (assoc 'stderr resp)))))
               (switch-to-buffer-other-window "*literate-org-error*")))))
    resp))
#+END_SRC


** Source Code Execution
*** customized variables for server host and port
#+BEGIN_SRC elisp
(defcustom literate-org-rest-server "http://localhost:7330/"
  "The server address for literate python server."
  :type 'string
  :group 'literate-org)

#+END_SRC
*** execute source codes in specified module for org-babel-python-evaluate
#+BEGIN_SRC elisp
(defun literate-org-setup-org-babel ()
  (setf org-babel-python--exec-tmpfile
        "\
with open('%s') as __org_babel_python_tmpfile:
    exec(compile(__org_babel_python_tmpfile.read(), __org_babel_python_tmpfile.name, 'exec'))"))
#+END_SRC
*** execute source code in remote server
#+BEGIN_SRC elisp
(cl-defun literate-org-remote-execute-code (code &key (type :exec) (module) (module-create-method "import_or_create"))
  (literate-org-request "execute" :type "POST"
                           :data `((type . ,(subseq (symbol-name type) 1))
                                   (module . ,module)
                                   (module-create-method . ,module-create-method)
                                   (code . ,code))))
#+END_SRC
*** execute source code in current code block
We have to switch back to org buffer, otherwise =org-babel-execute-src-block-maybe= will report a message and
override our own compilation report.
#+BEGIN_SRC elisp
(defun literate-org-execute-current-code-block ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (block-arguments (third (org-babel-get-src-block-info)))
         (info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (code (plist-get context-info :value))
         (type (intern (or (org-entry-get (point) "LITERATE_ORG_EXECUTE_TYPE" t)
                           ":exec")))
         (module-create-method (or (org-entry-get (point) "LITERATE_ORG_MODULE_CREATE_METHOD" t)
                                   "import_or_create"))
         (module-name (org-entry-get (point) "LITERATE_ORG_MODULE" t))
         (resp (literate-org-remote-execute-code code :type type :module module-name :module-create-method module-create-method)))
    (with-current-buffer (get-buffer-create "*literate-org-stdout*")
      (awhen (cdr (assoc 'stdout resp))
        (goto-char (point-max))
        (insert "\n" it "\n")))
    (if (equal type :exec)
      (message "Executed code block in module %s, updated locals %s"
               module-name (cdr (assoc 'locals resp)))
      (let ((json-encoding-pretty-print t))
        (when (not (equal "none" (cdr (assoc :results block-arguments))))
          (org-babel-insert-result (json-encode (cdr (assoc 'result resp))) '("replace")))
        (message "Evaluated code block in module %s:\n%s" module-name (cdr (assoc 'result resp)))))))
#+END_SRC
*** get top level python code
#+BEGIN_SRC elisp
(defun literate-org-get-top-level-node-at-point ()
  "Get the current top level node at point, return a cons of start and end position."
  (let* ((node (treesit-node-at (point)))
         (parent (treesit-node-parent node)))
    (while (and parent (not (equal "module" (treesit-node-type parent))))
      (setq node parent)
      (setq parent (treesit-node-parent node)))
    node))
#+END_SRC
*** get the module name for a file name
#+BEGIN_SRC elisp
(cl-defun literate-org-module-name-from-file-name (&optional (file (buffer-file-name)))
  "Get the module name from a file name."
  (let* ((package-root (lsp-workspace-root))
         (relative-name (f-no-ext (f-relative file package-root))))
    (when (locate-dominating-file relative-name "site-packages")
      (setf relative-name (apply 'f-join (nthcdr 4 (split-string relative-name "/")))))
    (dired-replace-in-string "/" "." relative-name)))
#+END_SRC
*** load python code to current module
#+BEGIN_SRC elisp
(defun literate-org-load-code-in-current-namespace ()
  (interactive)
  (let* ((node (literate-org-get-top-level-node-at-point))
         (begin (treesit-node-start node))
         (end (treesit-node-end node))
         (code (buffer-substring-no-properties begin end))
         (file (buffer-file-name))
         (org-babel-p (equalp "org" (f-ext file)))
         (module-name (if org-babel-p
                        (org-entry-get (point) "LITERATE_ORG_MODULE" t)
                        (literate-org-module-name-from-file-name file)))
         (module-create-method (or (org-entry-get (point) "LITERATE_ORG_MODULE_CREATE_METHOD" t)
                                   "import_or_create")))
    ;; To Fix module name with syntax `...literate-org.literate_python.module_a'
    (let ((prefix-dot-count 0))
      (while (eq ?. (aref module-name prefix-dot-count))
        (incf prefix-dot-count))
      (let ((index prefix-dot-count))
        (while (> prefix-dot-count 1)
          (setf index (1+ (position ?. module-name :start index)))
          (decf prefix-dot-count))
        (when (> index 0)
          (setf module-name (substring module-name index)))))

    (literate-org-remote-execute-code code :type :exec :module module-name :module-create-method module-create-method)
    (message "Loaded %s[%s:%s] in module %s" (treesit-node-type node) begin end module-name)))
#+END_SRC
* Python inspector for Emacs
:PROPERTIES:
:LITERATE_ORG_MODULE: literate_python.inspector
:header-args: :tangle ./literate_python/inspector.py
:END:
*** Import required packages
#+BEGIN_SRC python
from inspect import getmembers, isbuiltin, ismethod
from typing import Dict
from datetime import datetime
from multimethod import multimethod

#+END_SRC
*** Utility functions
**** stringify a variable
#+BEGIN_SRC python
def stringify_val(member):
    key, val = member
    if isinstance(val, str):
        return key, '"{}"'.format(val)
    if type(val) in (dict, tuple, list):
        return key, _inspect(val)
    return key, f"{str(val)} {str(type(val))}"

#+END_SRC
**** is trash
#+BEGIN_SRC python
def is_trash(member):
    key, val = member
    return (
        key in ["__doc__", "__class__", "__hash__", "__dict__"]
        or ismethod(val)
        or isbuiltin(val)
        or type(val).__name__ == "method-wrapper"
    )

#+END_SRC
**** Turns a non-primitive obj into a dictionary of its fields and their values.
#+BEGIN_SRC python
def _pyinspect_inspect_object(obj):
    """
    Turns a **non-primitive** obj into a dictionary of its fields and their values.
    Filters out some built-in magic fields and pretty-prints dictionary values via `json.dumps`.
    Doesn't display methods.
    """
    return dict(stringify_val(m) for m in reversed(getmembers(obj)) if not is_trash(m))

#+END_SRC
**** Surrounds string key with extra quotes
#+BEGIN_SRC python
def _pyinspect_add_quotes(key):
    """
    Surrounds string key with extra quotes because Emacs parses them as just symbols
    and makes it hard to distinguish between them and non-string symbols

    >>> _pyinspect_add_quotes("hello")
    '"hello"'

    >>> _pyinspect_add_quotes(1)
    1
    """
    return '"{}"'.format(key) if type(key) is str else key

#+END_SRC
**** trim_seq
#+BEGIN_SRC python
def trim_seq(seq, elem_cap):
    if type(seq) is dict:
        return _pyinspect_take_dict(seq, elem_cap)
    elif type(seq) in (tuple, list):
        return seq[:elem_cap]

#+END_SRC
**** Returns a new dictionary with the first n pairs from d
#+BEGIN_SRC python
def _pyinspect_take_dict(d: Dict, n: int):
    "Returns a new dictionary with the first n pairs from d"

    def iterator():
        i = 0
        for item in d.items():
            if i == n:
                break
            yield item
            i += 1

    return dict(iterator())

#+END_SRC
*** Dispatches the appropriate inspection according to obj type
**** generic method
#+BEGIN_SRC python
@multimethod
def _inspect(obj) -> dict:
    return {"type": "object", "value": _pyinspect_inspect_object(obj)}

#+END_SRC
**** str
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: str) -> dict:
    return {"type": "string", "value": obj}

#+END_SRC
**** bool
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: bool) -> dict:
    return {"type": "bool", "value": obj}

#+END_SRC
**** int
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: int) -> dict:
    return {"type": "integer", "value": obj}
#+END_SRC

**** float
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: float) -> dict:
    return {"type": "float", "value": obj}
#+END_SRC

**** complex
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: complex) -> dict:
    return {"type": "complex", "value": obj}
#+END_SRC
**** tuple
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: tuple) -> dict:
    return {
        "type": "tuple",
        "value": [_inspect(item) for item in obj],
    }

#+END_SRC

**** list
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: list) -> dict:
    return {
        "type": "list",
        "value": [_inspect(item) for item in obj],
    }

#+END_SRC

**** dict
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: dict) -> dict:
    return {
        "type": "dict",
        "value": {_pyinspect_add_quotes(k): _inspect(v) for (k, v) in obj.items()},
    }

#+END_SRC

**** datetime
#+BEGIN_SRC python
@_inspect.register  # type: ignore
def _(obj: datetime) -> dict:
    print(f"obj: {obj}")
    return {
        "type": "datetime",
        "value": obj.isoformat(),
    }

#+END_SRC

*** inspect as json
#+BEGIN_SRC python
# def _pyinspect_json(obj):
#     return json.dumps(_inspect(obj), indent=4, default=lambda o: _pyinspect(o)["value"])

#+END_SRC
* Sync between org files and source files
:PROPERTIES:
:literate-lang: elisp
:END:
** Introduction
Even though we can write code in org files,
we still need to sync them with source files,
especially when we want to share the code with a team or
import code changes from a team.
** Import
*** How
We try to import code from source files to an org file
by using Emacs's new library [[https://tree-sitter.github.io/tree-sitter/using-parsers][tree-sitter]].

For example, in the following Python code block,
we can parse the Python code and get the first function name.
#+BEGIN_SRC elisp :load no
(with-temp-buffer
    ;; (insert "def say_hello():\n  print('Hello')\n")
    (insert "yaml.add_representer(Canonical, dataclass_representer)\n")
  (let ((language (tree-sitter-require 'python))
        (parser (tsc-make-parser)))
    (tsc-set-language parser language)
    (let* ((str (buffer-string))
           (tree (tsc-parse-string parser str))
           (root (tsc-root-node tree))
           (first-child (tsc-get-nth-child root 0))
           (first-child-name (tsc-get-child-by-field first-child :name)))
      ;; (message "first child node type: %s, name:%s" (tsc-node-type first-child) (tsc-node-text first-child-name))
      (let ((grandchild (tsc-get-nth-child first-child 0)))
        (message "%s" (tsc-node-text (tsc-get-child-by-field grandchild :function))))
      ;; (message "%s" (tsc-tree-to-sexp tree))
      )))
#+END_SRC

*** Implementation
**** import required elisp libraries
#+BEGIN_SRC elisp
(require 'tree-sitter)
(require 'tree-sitter-langs)
(require 'f); for file operations
#+END_SRC
**** Configurations
***** ignored directories
#+BEGIN_SRC elisp
(defcustom literate-org-ignored-dirs '("__pycache__" ".git" ".vscode" ".idea")
  "The directories to be ignored when importing source files."
  :group 'literate-org)
#+END_SRC

***** the maximum size of a title for an org section
#+BEGIN_SRC elisp
(defcustom literate-org-max-title-size 80
  "The maximum size of a title for an org section."
  :group 'literate-org)
#+END_SRC
**** data structure
***** code block
#+BEGIN_SRC elisp
(cl-defstruct literate-org-code-block
  title
  body
  language
  properties
  level)
#+END_SRC

**** generic methods
#+BEGIN_SRC elisp
(cl-defgeneric literate-org-module-comment (language node)
  (:documentation "Get the module comment."))

(cl-defgeneric literate-org-node-name (language node-type node)
  (:documentation "Get the name of a node."))
(cl-defgeneric literate-org-next-code-block-index (language root start-index)
  (:documentation "Get the next code block index."))

(cl-defgeneric literate-org-file-extension (language)
  (:documentation "the file extension for a language."))

(cl-defgeneric literate-org-alias-language (language)
  (:documentation "the alias language for a language if have.")
  (:method (language)
    ;; default implementation
    language))

(cl-defgeneric literate-org-treesit-parser-language (language)
  (:documentation "Get the treesit parser language for a language."))

(cl-defgeneric literate-org-babel-language-name (language)
  (:documentation "the source code block name for a language."))

(cl-defgeneric literate-org-properties-for-a-module (language module-name path)
  (:documentation "the default header-args for a file."))

(cl-defgeneric literate-org-get-code-blocks-in-current-buffer (language module-name section-level)
  (:documentation "Get the code blocks in a file."))

#+END_SRC
**** Utilities
***** the parse tree for current file
#+BEGIN_SRC elisp
(cl-defun literate-org-parse-tree-for-current-file (language)
  (let* ((language (literate-org-treesit-parser-language language))
         (language (tree-sitter-require language))
         (parser (tsc-make-parser)))
    (tsc-set-language parser language)
    (tsc-parse-string parser (buffer-string))))
#+END_SRC

**** default implementation for generic methods
***** babel block language name
#+BEGIN_SRC elisp
(cl-defmethod literate-org-babel-language-name (language)
  (symbol-name language))
#+END_SRC

***** module comment for a language
#+BEGIN_SRC elisp
(cl-defmethod literate-org-module-comment (language node)
  nil)
#+END_SRC

***** file extensions for a language
#+BEGIN_SRC elisp
(cl-defmethod literate-org-file-extension (language)
  (symbol-name language))
#+END_SRC

***** determine treesit parser language in current buffer
#+BEGIN_SRC elisp
(cl-defmethod literate-org-treesit-parser-language (language)
  language)
#+END_SRC


***** How to get the name of a parse node
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name (language node-type node)
  (format "%s" node-type))
#+END_SRC

***** header-args for a file
#+BEGIN_SRC elisp
(cl-defmethod literate-org-properties-for-a-module (language module-name path)
  (list (cons "LITERATE_ORG_MODULE" module-name)
        (cons "header-args" (format ":tangle %s" path))))
#+END_SRC

***** get pieces of code blocks in a source file
To investigate the parse tree, we can use Emacs command [[https://github.com/emacs-mirror/emacs/blob/master/admin/notes/tree-sitter/starter-guide#query-references][treesit-explore-mode]]
#+BEGIN_SRC elisp
(cl-defmethod literate-org-get-code-blocks-in-current-buffer (language module-name section-level)
  (let* ((language (literate-org-alias-language language))
         (tree (literate-org-parse-tree-for-current-file language))
         (root (tsc-root-node tree))
         (count-of-children (tsc-count-children root))
         (module-comment (when (> count-of-children 0)
                           (literate-org-module-comment language root)))
         (current-index 0)
         (next-index 0)
         (next-title nil)
         (code-blocks nil))
    (while (< current-index count-of-children)
      (cl-multiple-value-setq (next-index next-title)
        (literate-org-next-code-block-index language root current-index))
      (setf code-blocks
              (nconc code-blocks
                     (list
                      (make-literate-org-code-block
                       :title (dired-replace-in-string "\n" " " next-title)
                       :body (let ((begin (tsc-node-start-position (ts-get-nth-child root current-index)))
                                   (end (tsc-node-end-position (ts-get-nth-child root next-index))))
                               (concat (buffer-substring-no-properties begin end) "\n"))
                       :language language
                       :level section-level))))
      (setf current-index (1+ next-index)))
    (cons module-comment code-blocks)))
#+END_SRC

**** import source files
***** how to prepare a new org section for a module
#+BEGIN_SRC elisp
(cl-defun literate-org-new-org-section-for-a-module (module-name new-level &key (title module-name) language path)
  (loop repeat new-level do (insert "*"))
  (insert " " title "\n")
  (cl-loop for (key . value) in (literate-org-properties-for-a-module language module-name path)
           do (org-entry-put (point) key value)))
#+END_SRC
***** iterate a directory or a file to import source files
#+BEGIN_SRC elisp
(cl-defun literate-org-import (&key (level (or (org-current-level) 0))
                                    module-name module-path)
  "Import source codes from a directory to an org file."
  (interactive "")
  (let* ((module-name (or module-name
                          (or (org-entry-get (point) "LITERATE_ORG_MODULE" t)
                              (org-entry-get (point) "LITERATE_ORG_ROOT_MODULE" t))))
         
         (root-path (org-entry-get (point) "LITERATE_ORG_ROOT_MODULE_PATH" t))
         (module-path (or module-path
                          (when root-path
                            (concat root-path "/"
                                    (dired-replace-in-string
                                     "\\." "/" module-name))))))
    (if (f-directory? module-path)
      (literate-org-import-directory module-name module-path)
      (literate-org-import-file module-name module-path))
    (message "Finished importing module %s from %s" module-name module-path)))
#+END_SRC
***** import a directory
#+BEGIN_SRC elisp
(defun literate-org-import-directory (module-name module-directory)
  (let* ((languages (or (aand (org-entry-get (point) "LITERATE_ORG_LANGUAGES" t)
                              (mapcar #'intern (split-string it)))
                        (aand (org-entry-get (point) "LITERATE_ORG_LANGUAGE" t)
                              (list (intern it)))
                        (list (intern (read-from-minibuffer "Which language: ")))))
         (new-level (1+ level)))
    ;; TODO: cleanup empty directories.
    (dolist (file (directory-files module-directory t))
      (when-let* ((ext (f-ext file))
                  (language (find-if #'(lambda (language)
                                         (equal ext (literate-org-file-extension language)))
                                     languages)))
        (let* ((relative-name (f-no-ext (f-relative file module-directory)))
               (new-module-name (format "%s.%s" module-name
                                        (dired-replace-in-string
                                         "/" "." relative-name))))
          (literate-org-import-source-file-to-org
           language file new-level new-module-name))))

    (dolist (directory (f-directories module-directory))
      (let* ((relative-name (f-no-ext (f-relative directory module-directory)))
             (new-module-name (format "%s.%s" module-name
                                      (dired-replace-in-string
                                       "/" "." relative-name))))
        (unless (loop for ignored-name in literate-org-ignored-dirs
                      thereis (search ignored-name new-module-name))
          (literate-org-new-org-section-for-a-module
           new-module-name new-level
           :title (or (f-ext relative-name) relative-name)
           :path directory)
          (literate-org-import :level new-level
                               :module-name new-module-name
                               :module-path directory))))))
#+END_SRC

***** import a file
#+BEGIN_SRC elisp
(defun literate-org-import-file (module-name module-path)
  (let* ((languages (or (aand (org-entry-get (point) "LITERATE_ORG_LANGUAGES" t)
                              (mapcar #'intern (split-string it)))
                        (aand (org-entry-get (point) "LITERATE_ORG_LANGUAGE" t)
                              (list (intern it)))
                        (intern (read-from-minibuffer "Which language: "))))
         (language
           (if (null (cdr languages))
             (car languages)
             (intern (completing-read "Which language: " languages))))
         (path-extension (literate-org-file-extension language))
         (path (concat module-path "." path-extension)))
    (when (f-exists-p path)
      (literate-org-import-source-file-to-org
       language path level module-name :with-org-section nil))))
#+END_SRC

**** build org sections for a file
#+BEGIN_SRC elisp
(cl-defun literate-org-import-source-file-to-org
    (language file level module-name &key (with-org-section t))
  (message "literate importing module %s from file %s with language %s" module-name file language)
  (let* ((new-level (1+ level))
         (code-blocks-info
           (with-current-buffer (find-file-noselect file)
             (literate-org-get-code-blocks-in-current-buffer language module-name new-level)))
         (module-comment (car code-blocks-info))
         (module-title (when module-comment
                         (first (split-string module-comment "\n" t nil))))
         (code-blocks (cdr code-blocks-info)))
    (when with-org-section
      (literate-org-new-org-section-for-a-module module-name level
                                                 :language language
                                                 :path file
                                                 :title (or module-title (f-ext module-name) module-name))
      (let* ((module-root-path (org-entry-get (point) "LITERATE_ORG_ROOT_MODULE_PATH" t))
             (root-module (org-entry-get (point) "LITERATE_ORG_ROOT_MODULE" t)))
        (when (and (> (length module-root-path) 0)
                   (not (string-suffix-p "/" module-root-path)))
          (setf module-root-path (concat module-root-path "/")))))

    (cl-loop for block in code-blocks do
             (cl-loop repeat (literate-org-code-block-level block) do (insert "*"))
             (insert " " (literate-org-code-block-title block) "\n")
             (cl-loop for (key . value) in (literate-org-code-block-properties block)
                      do (org-entry-put (point) key value))
             (awhen (literate-org-code-block-body block)
               (insert "#+BEGIN_SRC "
                       (literate-org-babel-language-name (literate-org-code-block-language block))
                       "\n")
               (insert it)
               (insert "\n#+END_SRC\n")))))
#+END_SRC
**** Python
***** module comment for a language
The comment for a module is usually the first string in the Python file before any meaning code.
#+BEGIN_SRC elisp
(cl-defmethod literate-org-module-comment ((language (eql python)) node)
  (when (eq 'module (tsc-node-type node)) 
    (let* ((index 0)
                (child (tsc-get-nth-child node index)))
      (while (and child
                  (eq 'comment (tsc-node-type child)))
        (incf index)
        (setq child (tsc-get-nth-child node index)))
      (when (and child
                 (eq 'expression_statement (tsc-node-type child)))
        (setf child (tsc-get-nth-child child 0))
        (when (eq 'string (tsc-node-type child))
          (tsc-node-text (tsc-get-nth-child child 1)))))))
#+END_SRC
***** file extensions for a language
#+BEGIN_SRC elisp
(cl-defmethod literate-org-file-extension ((language (eql python)))
  "py")
#+END_SRC


***** How to get the name of a parse node
****** function definition
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql function_definition)) node)
  (format "Function %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** class_definition
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql class_definition)) node)
  (format "Class %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** decorated_definition
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql decorated_definition)) node)
  (let* ((name-list nil)
         (index 0)
         (child (tsc-get-nth-child node index)))
    (while (eq 'decorator (tsc-node-type child))
      (setf name-list (nconc name-list (list (tsc-node-text (tsc-get-nth-child child 1)))))
      (incf index)
      (setf child (tsc-get-nth-child node index)))
    (format "@%s: %s" (mapconcat 'identity name-list " ")
            (literate-org-node-name language (tsc-node-type child) child))))
#+END_SRC
****** assignment
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql assignment)) node)
  (let ((code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length code) literate-org-max-title-size)
      (format "Assignment %s" code)
      (format "Assignment %s" (tsc-node-text (tsc-get-child-by-field node :left))))))
#+END_SRC

****** augmented_assignment
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql augmented_assignment)) node)
  (let ((code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length code) literate-org-max-title-size)
      (format "Assignment %s" code)
      (format "Assignment %s" (tsc-node-text (tsc-get-child-by-field node :left))))))
#+END_SRC
****** call
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql call)) node)
  (let ((call-code (dired-replace-in-string "\n" " " (tsc-node-text node))))
    (if (<= (length call-code) literate-org-max-title-size)
      (format "Call %s" call-code)
      (format "Call %s" (tsc-node-text (tsc-get-child-by-field node :function))))))
#+END_SRC

****** try
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql try_statement)) node)
  "Try statement")
#+END_SRC

****** while
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql while_statement)) node)
  "While statement")
#+END_SRC

****** string
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql string)) node)
  "String")
#+END_SRC

****** comment
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql comment)) node)
  "Comment")
#+END_SRC

****** import
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql import)) node)
  "Import")
#+END_SRC
****** import_from_statement
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql import_from_statement)) node)
  "Import")
#+END_SRC

****** expression
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql python))
                                      (node-type (eql expression_statement)) node)
  (let ((new-node (tsc-get-nth-child node 0)))
    (literate-org-node-name language (ts-node-type new-node) new-node)))
#+END_SRC


***** get the next code block index
#+BEGIN_SRC elisp
(cl-defmethod literate-org-next-code-block-index ((language (eql python))
                                                  root start-index)
  (cl-block nil
    (let* ((max-index (1- (tsc-count-children root)))
           (current-index start-index)
           (current-node nil)
           (current-node-type nil)
           (next-index nil)
           (next-node-type nil)
           (next-node nil)
           (next-title nil)
           (collected-valid-node-types nil)
           (previous-node nil)
           (previous-node-type nil))
      (while (<= current-index max-index)
        (setf previous-node current-node)
        (setf previous-node-type current-node-type)
        (setf current-node (ts-get-nth-child root current-index))
        (setf current-node-type (ts-node-type current-node))
        (unless (eq 'comment current-node-type)
          (push current-node-type collected-valid-node-types))

        (when (= current-index max-index)
          (return (values max-index
                          (literate-org-node-name
                           language current-node-type current-node))))
        (setf next-index (1+ current-index)
              next-node (ts-get-nth-child root next-index)
              next-node-type (ts-node-type next-node))
        (cl-case current-node-type 
          (comment 
           (if (and previous-node-type
                    (not (find previous-node-type '(comment)) )
                    (find (first collected-valid-node-types) '(import_statement import_from_statement))
                    (not (find next-node-type '(import_statement import_from_statement comment))))
             (return (values (1- current-index)
                             (literate-org-node-name
                              language previous-node-type previous-node)))
             (incf current-index)))
          ((import_statement import_from_statement)
           (cond ((find next-node-type '(import_statement import_from_statement comment))
                  (incf current-index))
                 (t
                  (return (values current-index "Import statements")))))
          (decorated_definition
           (return (values current-index
                           (literate-org-node-name
                            language current-node-type current-node))))
          (class_definition
           (return (values current-index
                           (literate-org-node-name
                            language current-node-type current-node))))
          (function_definition
           (return (values current-index
                           (literate-org-node-name
                            language current-node-type current-node))))
          (expression_statement
           (let* ((first-child-node (ts-get-nth-child current-node 0))
                  (first-child-node-type (ts-node-type first-child-node)))
             (cl-case first-child-node-type
               (comment
                (incf next-index)
                (setf next-node (ts-get-nth-child root next-index))
                (setf next-node-type (ts-node-type next-node)))
               (string
                (return (values current-index "Docstring")))
               (assignment
                ;; if there is a docstring for this assignment, continue to next index
                (if (and (eq 'expression_statement next-node-type)
                         (eq 'string (ts-node-type (ts-get-nth-child next-node 0))))
                  (incf current-index)
                  (return (values current-index
                                  (literate-org-node-name
                                   language first-child-node-type first-child-node)))))
               (t
                (return (values current-index
                                (literate-org-node-name
                                 language first-child-node-type first-child-node)))))))
          (t
           (incf current-index)))))))
#+END_SRC

**** vue
***** How to get the name of a parse node
****** function definition
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql function_declaration)) node)
  (format "Function %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** string
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql string)) node)
  "String")
#+END_SRC

****** comment
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql comment)) node)
  "Comment")
#+END_SRC

****** import
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql import)) node)
  "Import")
#+END_SRC
****** export
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql export_statement)) node)
  (format "Export %s"
          (let ((declaration (tsc-get-child-by-field node :declaration)))
            (if declaration
              (literate-org-node-name language (tsc-node-type declaration) declaration)
              (let ((value (tsc-get-child-by-field node :value)))
                (if value
                  (tsc-node-text value)))))))
#+END_SRC
****** type_alias_declaration
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql type_alias_declaration)) node)
  (format "Type %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC


****** enum_declaration
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql enum_declaration)) node)
  (format "Enum %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** interface_declaration
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql interface_declaration)) node)
  (format "Interface %s" (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** lexical
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql lexical_declaration)) node)
  (format "%s %s"
          (tsc-node-text (tsc-get-child-by-field node :kind))
          (let ((sub-node (tsc-get-nth-child node 1)))
            (literate-org-node-name language
                                    (tsc-node-type sub-node)
                                    sub-node))))
#+END_SRC

****** variable_declarator
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql variable_declarator)) node)
  (format "Variable %s"
          (tsc-node-text (tsc-get-child-by-field node :name))))
#+END_SRC

****** expression
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql tsx))
                                      (node-type (eql expression_statement)) node)
  (let ((new-node (tsc-get-nth-child node 0)))
    (literate-org-node-name language (ts-node-type new-node) new-node)))
#+END_SRC



***** get the next code block index
#+BEGIN_SRC elisp
(cl-defmethod literate-org-next-code-block-index ((language (eql vue))
                                                  root start-index)
  (let* ((current-index start-index)
         (current-node (ts-get-nth-child root current-index))
         (current-node-type (ts-node-type current-node)))
    (values current-index
            (literate-org-node-name
             language current-node-type current-node))))
#+END_SRC

***** org properties for a module
#+BEGIN_SRC elisp
(cl-defmethod literate-org-properties-for-a-module ((language (eql vue)) module-name path)
  (list (cons "LITERATE_ORG_MODULE" module-name)
        (cons "LITERATE_SOURCE_FILE" path)
        (cons "header-args" (format ":noweb yes :tangle %s" path))
        (cons "header-args:tsx" (format ":noweb yes :noweb-ref %s-script :tangle no" module-name))
        (cons "header-args:vue-html" (format ":noweb yes :noweb-ref %s-template :tangle no" module-name))
        (cons "header-args:css" (format ":noweb yes :noweb-ref %s-style :tangle no" module-name))))
#+END_SRC

***** determine treesit parser language in current buffer
#+BEGIN_SRC elisp
(cl-defmethod literate-org-treesit-parser-language ((language (eql vue)))
  'html)
#+END_SRC



***** get pieces of code blocks in a source file
To investigate the parse tree, we can use Emacs command [[https://github.com/emacs-mirror/emacs/blob/master/admin/notes/tree-sitter/starter-guide#query-references][treesit-explore-mode]]
#+BEGIN_SRC elisp
(cl-defmethod literate-org-get-code-blocks-in-current-buffer ((language (eql vue))
                                                              module-name section-level)
  (let* ((language (literate-org-alias-language language))
         (tree (literate-org-parse-tree-for-current-file language))
         (root (tsc-root-node tree))
         (count-of-children (tsc-count-children root))
         (module-comment (when (> count-of-children 0)
                           (literate-org-module-comment language root)))
         (main-items nil)
         (comment-blocks nil)
         (script-blocks nil)
         (elements-blocks nil)
         (style-blocks nil)
         (code-blocks nil))
    (cl-loop for index from 0 below count-of-children
             for node = (ts-get-nth-child root index)
             for children-count = (tsc-count-children node)
             for node-type = (tsc-node-type node)
             for node-start-text = (when (> children-count 0)
                                     (tsc-node-text (tsc-get-nth-child node 0)))
             for node-end-text = (when (> children-count 0)
                                   (tsc-node-text (tsc-get-nth-child node (1- children-count))))
             for node-body-noweb-ref = nil
             for body = (if (> children-count 0)
                          (string-join (loop for i from 1 below (1- children-count)
                                             collect (tsc-node-text (tsc-get-nth-child node i))))
                          (tsc-node-text node))
             do (labels ((%build (node-type &key language 
                                            mode
                                            (literate-lang (symbol-name language))
                                            (indent 0))
                           (values
                            (format "%s<<%s-%s>>"
                                    (string-join (loop repeat indent collect " "))
                                    module-name node-type)
                            (with-temp-buffer
                              (insert body)
                              ;; (when mode
                              ;;   (funcall mode)
                              ;;   (prettier-prettify))
                              (cons 
                               (make-literate-org-code-block
                                :title (format "%s of %s" node-type module-name)
                                :properties (list (cons "literate-lang" literate-lang))
                                :level section-level)
                               (cdr
                                (literate-org-get-code-blocks-in-current-buffer
                                 language
                                 (format "%s-" module-name node-type)
                                 (1+ section-level))))))))
                  (ecase node-type
                    (script_element
                     (multiple-value-bind (noweb-ref blocks)
                         (%build "script" :mode 'typescript-ts-mode :language 'tsx)
                       (setf node-body-noweb-ref noweb-ref
                             script-blocks (nconc comment-blocks blocks))))
                    (element
                     (multiple-value-bind (noweb-ref blocks)
                         (%build "template" :mode 'vue-mode :language 'vue-html :indent 2)
                       (setf node-body-noweb-ref noweb-ref
                             elements-blocks (nconc comment-blocks blocks))))
                    (style_element
                     (multiple-value-bind (noweb-ref blocks)
                         (%build "style" :language 'css)
                       (setf node-body-noweb-ref noweb-ref
                             style-blocks (nconc comment-blocks blocks))))
                    (comment
                     (let ((block (make-literate-org-code-block
                                   :title (format "Comment %s" module-name)
                                   :body body
                                   :language 'vue
                                   :level (1+ section-level))))
                     (setf node-body-noweb-ref nil
                           comment-blocks
                           (nconc comment-blocks (list block)))))))
             (when node-body-noweb-ref
               (setf comment-blocks nil)
               (let ((node-text (format "%s\n%s\n%s\n"
                                        node-start-text
                                        node-body-noweb-ref
                                        node-end-text)))
                 (setf main-items (nconc main-items (list node-text))))))
    (setf code-blocks
            (cons (make-literate-org-code-block
                   :title (format "Main wrapper %s" module-name)
                   :body (string-join main-items"\n")
                   :language 'vue
                   :level section-level)
                  (nconc script-blocks elements-blocks style-blocks)))
    (cons module-comment code-blocks)))
#+END_SRC


**** vue-html
***** determine treesit parser language in current buffer
#+BEGIN_SRC elisp
(cl-defmethod literate-org-treesit-parser-language ((language (eql vue-html)))
  'html)
#+END_SRC




***** literate-org-node-name

****** default
#+BEGIN_SRC elisp
(cl-defmethod literate-org-node-name ((language (eql vue-html)) node-type node)
  (aif (tsc-get-nth-child node 0)
    (tsc-node-text it)
    (tsc-node-text node)))
#+END_SRC

***** literate-org-next-code-block-index
#+BEGIN_SRC elisp
(cl-defmethod literate-org-next-code-block-index ((language (eql vue-html))
                                                  root start-index)
  (let* ((current-index start-index)
         (current-node (ts-get-nth-child root current-index))
         (current-node-type (ts-node-type current-node)))
    (values current-index
            (literate-org-node-name
             language current-node-type current-node))))
#+END_SRC
**** css
#+BEGIN_SRC elisp
(cl-defmethod literate-org-next-code-block-index ((language (eql css))
                                                  root start-index)
  (let* ((current-index (1- (tsc-count-children root)))
         (current-node (ts-get-nth-child root current-index))
         (current-node-type (ts-node-type current-node)))
    (values current-index
            (literate-org-node-name
             language current-node-type current-node))))
#+END_SRC


**** tsx
***** file extensions for a language
#+BEGIN_SRC elisp
(cl-defmethod literate-org-file-extension ((language (eql vue-html)))
  "vue")
#+END_SRC


***** alias language
#+BEGIN_SRC elisp
(cl-defmethod literate-org-alias-language ((language (eql ts)))
  'tsx)
#+END_SRC

***** get the next code block index
#+BEGIN_SRC elisp
(cl-defmethod literate-org-next-code-block-index ((language (eql tsx))
                                                  root start-index)
  (cl-block nil
    (let* ((max-index (1- (tsc-count-children root)))
           (current-index start-index)
           (current-node nil)
           (current-node-type nil)
           (next-index nil)
           (next-node-type nil)
           (next-node nil)
           (next-title nil)
           (collected-valid-node-types nil)
           (previous-node nil)
           (previous-node-type nil))
      (while (<= current-index max-index)
        (setf previous-node current-node)
        (setf previous-node-type current-node-type)
        (setf current-node (ts-get-nth-child root current-index))
        (setf current-node-type (ts-node-type current-node))
        (unless (eq 'comment current-node-type)
          (push current-node-type collected-valid-node-types))

        (when (= current-index max-index)
          (return (values max-index
                          (literate-org-node-name
                           language current-node-type current-node))))
        (setf next-index (1+ current-index)
              next-node (ts-get-nth-child root next-index)
              next-node-type (ts-node-type next-node))
        (case current-node-type 
          (comment 
           (if (and previous-node-type
                    (not (find previous-node-type '(comment)) )
                    (find (first collected-valid-node-types)
                          '(import_statement))
                    (not (find next-node-type
                               '(import_statement comment))))
             (return (values (1- current-index)
                             (literate-org-node-name
                              language previous-node-type previous-node)))
             (incf current-index)))
          (import_statement
           (cond ((find next-node-type
                        '(import_statement comment))
                  (incf current-index))
                 (t
                  (return (values current-index "Import statements")))))
          ((export_statement enum_declaration interface_declaration
                             type_alias_declaration
                             lexical_declaration
                             variable_declarator
                             function_declaration)
           (return (values current-index
                           (literate-org-node-name
                            language current-node-type current-node))))
          (expression_statement
           (let* ((first-child-node (ts-get-nth-child current-node 0))
                  (first-child-node-type (ts-node-type first-child-node)))
             (cl-case first-child-node-type
               (comment
                (incf next-index)
                (setf next-node (ts-get-nth-child root next-index))
                (setf next-node-type (ts-node-type next-node)))
               (string
                (return (values current-index "Docstring")))
               (assignment
                ;; if there is a docstring for this assignment, continue to next index
                (if (and (eq 'expression_statement next-node-type)
                         (eq 'string (ts-node-type (ts-get-nth-child next-node 0))))
                  (incf current-index)
                  (return (values current-index
                                  (literate-org-node-name
                                   language first-child-node-type first-child-node)))))
               (t
                (return (values current-index
                                (literate-org-node-name
                                 language first-child-node-type first-child-node)))))))
          (t
           (incf current-index)))))))
#+END_SRC

** Export
We use native org tangle features.
* Run python code in specified module
:PROPERTIES:
:literate-lang: elisp
:END:
** setup current module in python REPL
*** a special variable for current module name in python REPL
#+BEGIN_SRC elisp
(defvar literate-org-current-module nil
        "The current python module name to be used when execute a code.")
#+END_SRC
*** display namespace in the mode line in buffer for python REPL 
#+BEGIN_SRC elisp
(defun literate-org-current-namespace-in-repl ()
  `(
    "/"
    ,(or literate-org-current-module "*")
    "/"))
(add-to-list 'mode-line-misc-info
             `(inferior-python-mode (" [" literate-org-current-namespace-in-repl "] ")))
#+END_SRC
*** a comint input sender to exec code in a namespace.
#+BEGIN_SRC elisp
(defun literate-org-comint-input-sender (proc string)
  (with-current-buffer (process-buffer proc)
    (if (eq major-mode 'inferior-python-mode)
      (let ((new-string (format "__PYTHON_EL_eval(%s, %s)\n"
                                (python-shell--encode-string string)
                                (python-shell--encode-string (or (buffer-file-name)
                                                                 "<string>")))))
        (comint-simple-send proc new-string))
      (comint-simple-send proc string))))
#+END_SRC

** setup python shell eval setup code
#+BEGIN_SRC elisp
(defun literate-org-setup-shell-eval-setup-code ()
  (setf comint-input-sender (function literate-org-comint-input-sender))
  (setf python-shell-eval-setup-code
  "\
def __PYTHON_EL_eval(source, filename, module=None):
    import ast, sys
    import os
    if sys.version_info[0] == 2:
        from __builtin__ import compile, eval, globals
    else:
        from builtins import compile, eval, globals
    try:
        p, e = ast.parse(source, filename), None
    except SyntaxError:
        t, v, tb = sys.exc_info()
        sys.excepthook(t, v, tb.tb_next)
        return
    if p.body and isinstance(p.body[-1], ast.Expr):
        e = p.body.pop()
    try:
        g = globals()
        if module is None and 'python_repl_module_name' in globals():
           module = globals()['python_repl_module_name']
        if module is not None:
           g = sys.modules[module].__dict__
        exec(compile(p, filename, 'exec'), g, g)
        if e:
            return eval(compile(ast.Expression(e.value), filename, 'eval'), g, g)
    except Exception:
        t, v, tb = sys.exc_info()
        sys.excepthook(t, v, tb.tb_next)")
  )
#+END_SRC
* Utilities
** clear subtree
#+BEGIN_SRC elisp
(defun literate-org-clear-subtree ()
  (interactive)
  (org-mark-subtree) ;; mark the current subtree
  (forward-line) ;; move point forward, so the headline isn't in the region
  (when (string-prefix-p ":PROPERTIES:" (thing-at-point 'line t))
    (search-forward ":END:")
    (forward-line))
  (delete-region (region-beginning) (region-end)) ;; delete the rest
)
#+END_SRC

** import from jupyter notebook 
:PROPERTIES:
:literate-lang: elisp
:END:
*** convert markdown to org syntax
**** lua filter to remove PROPERTIES
#+BEGIN_SRC elisp
(defvar literate-org-lua-filter-remove-properties
    "
function Div(elem)
  -- Check if the Div is an Org PROPERTIES drawer
  if elem.classes:includes(\"PROPERTIES\") then
    -- Remove the entire PROPERTIES block by returning nothing
    return {}
  end
end
"
  "A lua filter to remove PROPERTIES drawer.")
#+END_SRC

**** main
#+BEGIN_SRC elisp
(defun literate-org-markdown-to-org (str)
  (let* ((lua-filter-file (make-temp-file "literate-org-md-to-org" nil ".lua"))
         (src-file (make-temp-file "literate-org-md-to-org" nil ".md"))
         (dest-file (format "%s.org" src-file)))
    (with-temp-file lua-filter-file
      (insert literate-org-lua-filter-remove-properties))
    (with-temp-file src-file
      (insert str))
    (shell-command (format "pandoc -f markdown -t org --lua-filter=\"%s\" -o \"%s\" \"%s\""
                           lua-filter-file dest-file src-file))
    (unwind-protect
        (with-temp-buffer
          (insert-file-contents dest-file)
          (buffer-string))
      (delete-file lua-filter-file)
      (delete-file src-file)
      (delete-file dest-file))))
#+END_SRC

**** Only tangling code definitions 
#+BEGIN_SRC elisp
(defvar literate-org-ipynb-tangled-prefix-patterns
    '("Function " "Class " "Import" "@"))

#+END_SRC

*** parse a notebook file
#+BEGIN_SRC elisp
(defun literate-org-import-ipynb-file (file)
  (interactive "f")
  (let* ((data (json-read-file file))
         (cells (coerce (cdr (assoc 'cells data)) 'list))
         (current-org-level (org-current-level)))
    (dolist (cell cells)
      (let ((cell-type (cdr (assoc 'cell_type cell)))
            (source (string-join (coerce (cdr (assoc 'source cell)) 'list))))
        (cond ((string= cell-type "code")
               (if (string-prefix-p "!" source) 
                 (progn
                   (loop repeat (1+ current-org-level) do (insert "*"))
                   (insert " A shell command" "\n")
                   (insert "#+BEGIN_SRC " "sh" "\n")
                   (insert (subseq source 1))
                   (insert "\n#+END_SRC\n"))
                 (let ((src-file (make-temp-file "literate-org-ipynb-code" nil ".py"))
                       (language 'python))
                   (with-temp-file src-file
                     (insert source))
                   (let ((code-blocks
                          (with-current-buffer (find-file-noselect src-file)
                            (cdr (literate-org-get-code-blocks-in-current-buffer
                                  language "" 1)))))
                     (delete-file src-file)
                     (loop for block in code-blocks do
                       (loop repeat (literate-org-code-block-level block) do (insert "*"))
                       (insert " " (literate-org-code-block-title block) "\n")
                       (insert "#+BEGIN_SRC " (literate-org-babel-language-name (literate-org-code-block-language block)))
                       (if (loop for prefix in literate-org-ipynb-tangled-prefix-patterns
                                 never (string-prefix-p prefix title))
                         (insert " :tangle no"))
                       (insert "\n" (literate-org-code-block-body block))
                       (insert "\n#+END_SRC\n"))))))
              ((string= cell-type "markdown")
               (insert (literate-org-markdown-to-org source) "\n")
               (setf current-org-level (org-current-level))))))))
#+END_SRC

* Tips
:PROPERTIES:
:header-args: :tangle no
:END:
** how to start django server in REPL
#+BEGIN_SRC python
import os
import django
from django.core.management import call_command
from threading import Thread

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
django.setup()

# Function to start the server
def start_server():
    call_command('runserver', '127.0.0.1:8000', '--noreload')

# Start the server in a new thread
server_thread = Thread(target=start_server)
server_thread.start()

print("Django server started on http://127.0.0.1:8000")
#+END_SRC
* TODO[0/1]
- [ ] After reloading a definition in a code block, all modules that depend on the module to which this definition belongs are automatically reloaded.
- [ ] Add support to noweb with tangle & code format.  
* References
- [[https://peps.python.org/pep-0302/][PEP 302 -- New Import Hooks]]
- [[https://nbdev.fast.ai/tutorials/tutorial.html][nbdev]] (Create delightful software with Jupyter Notebooks)
  - [[https://hallmx.github.io/nbd_colab/][nbd_colab]]
- [[https://emacs-tree-sitter.github.io/api/inspecting/][tree-sitter]]
